#!/usr/bin/sh

# x86-64 instructions: https://www.felixcloutier.com/x86/
# more reading: https://wiki.osdev.org/X86-64_Instruction_Encoding
#             - https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
#             /r                -> reg and r/m operand
#             ib, iw, id, io    -> immediate value byte size 1, 2, 4, 8
#             +rb, +rw, +rd +ro -> lower 3 opcode bits encode register

# ea -> effective memory address
set -e

FILE="byl"
EXPL="../test/test_only_entry_fn.byl"
SIZE=0
BYL=""

ax="000"
cx="001"
dx="010"
bx="011"
sp="100"
bp="101"
si="110"
di="111"
r8="000"
r9="001"
r10="010"
r11="011"
r12="100"
r13="101"
r14="110"
r15="111"

if test -e "$FILE" ; then
    rm "$FILE"
fi

write_zeroes () {
    for i in $(seq 1 "$1") ; do
        SIZE=$(expr $SIZE + 1)
        printf '\x00'
    done
}
write_u8  () {
    SIZE=$(expr $SIZE + 1)
    printf "\x$1"
}
write_b8 () {
    SIZE=$(expr $SIZE + 1)
    printf "\\$(printf '%o' "$((2#$1))")"
}
write_u16 () {
    SIZE=$(expr $SIZE + 2)
    printf "\x$2\x$1"
}
write_u32 () {
    SIZE=$(expr $SIZE + 4)
    printf "\x$4\x$3\x$2\x$1"
}
write_u64 () {
    SIZE=$(expr $SIZE + 8)
    printf "\x$8\x$7\x$6\x$5\x$4\x$3\x$2\x$1"
}

add_u32_imm8 () {
    if test ! -z $3 ; then
        write_u8 41
    fi
    write_u8 83
    write_b8 "11000${1}"
    write_u8 $2
}
add_u32_imm32 () {
    if test ! -z $6 ; then
        write_u8 41
    fi
    write_u8 81
    write_b8 "11000${1}"
    write_u32 $2 $3 $4 $5
}
add_u64_imm32 () {
    REX=48
    if test ! -z $6 ; then
        REX=49
    fi
    write_u16 81 $REX
    write_b8 "11000${1}"
    write_u32 $2 $3 $4 $5
}

and_u32_imm32 () {
    if test ! -z $6 ; then
        write_u8 41
    fi
    write_u8 81
    write_b8 "11100${1}"
    write_u32 $2 $3 $4 $5
}
and_u64_imm32 () {
    REX=48
    if test ! -z $6 ; then
        REX=49
    fi
    write_u16 81 $REX
    write_b8 "11100${1}"
    write_u32 $2 $3 $4 $5
}

call_imm32 () {
    write_u8 e8
    write_u32 $1 $2 $3 $4
}

cmovq_u32_u32 () {
    if test ! -z $3 ; then
        REX=45
        if test $3 -eq "0" ; then
            REX=44
        elif test $3 -eq "1" ; then
            REX=41
        fi
        write_u8 $REX
    fi
    write_u16 44 0f
    write_b8 "11${1}${2}"
}

cmp_u32_imm8 () {
    if test ! -z $3 ; then
        write_u8 41
    fi
    write_u8 83
    write_b8 "11111${1}"
    write_u8 $2
}
cmp_u32_u32 () {
    if test ! -z $3 ; then
        REX=45
        if test $3 -eq "0" ; then
            REX=44
        elif test $3 -eq "1" ; then
            REX=41
        fi
        write_u8 $REX
    fi
    write_u8 3b
    write_b8 "11${1}${2}"
}
cmp_u64_imm8 () {
    REX=48
    if test ! -z $3 ; then
        REX=49
    fi
    write_u8 $REX
    write_b8 "11111${1}"
    write_u8 $2
}
cmp_u64_u64 () {
    REX=48
    if test ! -z $3 ; then
        REX=4d
        if test $3 -eq "0" ; then
            REX=4c
        elif test $3 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 3b $REX
    write_b8 "11${1}${2}"
}

inc_u32 () {
    if test ! -z $2 ; then
        write_u8 41
    fi
    write_u8 ff
    write_b8 "11000${1}"
}
inc_u64 () {
    REX=48
    if test ! -z $2 ; then
        REX=49
    fi
    write_u16 ff $REX
    write_b8 "11000${1}"
}

jmp_imm8 ()     { 
    write_u16 $1 eb
}
jmp_imm32 ()    {
    write_u8 e9
    write_u32 $1 $2 $3 $4
}
jcc_g_imm8 ()   { 
    write_u16 $1 7f
}
jcc_gq_imm8 ()  { 
    write_u16 $1 73
}
jcc_l_imm8 ()   { 
    write_u16 $1 72
}
jcc_lq_imm8 ()  { 
    write_u16 $1 76 
}
jcc_q_imm8 ()   { 
    write_u16 $1 74
}
jcc_q_imm32 ()  {
    write_u16 84 0f
    write_u32 $1 $2 $3 $4
}
jcc_nq_imm8 ()  { 
    write_u16 $1 75
}
jcc_s_imm8 ()   { 
    write_u16 $1 78
}
jcc_ns_imm8 ()  { 
    write_u16 $1 79
}

lea_u64_ea_u64 () {
    REX=48
    if test ! -z $3 ; then
        REX=4d
        if test $3 -eq "0" ; then
            REX=4c
        elif test $3 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 8d $REX
    write_b8 "00${1}${2}"
}
lea_u64_ea_u64_disp8 () {
    REX=48
    if test ! -z $4 ; then
        REX=4d
        if test $4 -eq "0" ; then
            REX=4c
        elif test $4 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 8d $REX
    write_b8 "01${1}${2}"
    write_u8 $3
}
lea_u64_ea_u64_base_u64 () {
    REX=48
    if test ! -z $4 ; then
        if test $4 -eq "0" ; then
            REX=4c
        elif test $4 -eq "1" ; then
            REX=49
        elif test $4 -eq "2" ; then
            REX=4a
        elif test $4 -eq "01" ; then
            REX=4d
        elif test $4 -eq "02" ; then
            REX=4e
        elif test $4 -eq "12" ; then
            REX=4b
        fi
    fi
    write_u16 8d $REX
    write_b8 "00${1}${sp}"
    write_b8 "00${3}${2}"
}

mov_u32_imm32 () {
    if test ! -z $6 ; then
        write_u8 41
    fi
    write_u8 c7
    write_b8 "11000${1}"
    write_u32 $2 $3 $4 $5
}
mov_u32_u32 () {
    if test ! -z $3 ; then
        REX=45
        if test $3 -eq "0" ; then
            REX=44
        elif test $3 -eq "1" ; then
            REX=41
        fi
        write_u8 $REX
    fi
    write_u8 8b
    write_b8 "11${1}${2}"
}
mov_u64_imm64 () {
    reg="${1}"
    shift

    REX=48
    if test ! -z $9 ; then
        REX=49
    fi
    write_u8 $REX
    write_b8 "10111${reg}" # +rd
    write_u64 $1 $2 $3 $4 $5 $6 $7 $8
}
mov_u64_u64 () {
    REX=48
    if test ! -z $3 ; then
        REX=4d
        if test $3 -eq "0" ; then
            REX=4c
        elif test $3 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 8b $REX
    write_b8 "11${1}${2}"
}
mov_u64_ea_u64 () {
    REX=48
    if test ! -z $3 ; then
        REX=4d
        if test $3 -eq "0" ; then
            REX=4c
        elif test $3 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 8b $REX
    write_b8 "00${1}${2}"
    write_b8 "00${sp}${2}"
}
mov_u64_ea_u64_disp8() {
    REX=48
    if test ! -z $4 ; then
        REX=4d
        if test $4 -eq "0" ; then
            REX=4c
        elif test $4 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 8b $REX
    write_b8 "01${1}${2}"
    write_b8 "00${sp}${2}"
    write_u8 $3
}
mov_u64_ea_u64_disp32 () {
    REX=48
    if test ! -z $7 ; then
        REX=4d
        if test $7 -eq "0" ; then
            REX=4c
        elif test $7 -eq "1" ; then
            REX=49
        fi
    fi
    write_u16 8b $REX
    write_b8 "10${1}${2}"
    write_u32 $3 $4 $5 $6
}

movzx_u32_ea_byte_ptr_u64_base_u64 () {
    if test ! -z $4 ; then
        REX=47
        if test $4 -eq "0" ; then
            REX=44
        elif test $4 -eq "1" ; then
            REX=41
        elif test $4 -eq "2" ; then
            REX=42
        elif test $4 -eq "01" ; then
            REX=45
        elif test $4 -eq "02" ; then
            REX=46
        elif test $4 -eq "12" ; then
            REX=43
        fi
        write_u8 $REX
    fi
    write_u16 b6 0f
    write_b8 "00${1}${2}"
    write_b8 "00${3}${2}"
}

neg_u64 () {
    REX=48
    if test ! -z $2 ; then
        REX=49
    fi
    write_u8 f7 $REX
    write_b8 "11011${1}"
}

pop_u64 () {
    REX=48
    if test ! -z $2 ; then 
        REX=49
    fi
    write_u16 8f $REX
    write_b8 "11000${1}"
}

push_u64 () {
    REX=48
    if test ! -z $2 ; then 
        REX=49
    fi
    write_u16 ff $REX
    write_b8 "11110${1}"
}

ret () { 
    write_u8 c3
}

shl_u64_imm8 () {
    REX=48
    if test ! -z $3 ; then
        REX=49
    fi
    write_u16 c1 $REX
    write_b8 "11100${1}"
    write_u8 $2
}
shl_u64_once () {
    REX=48
    if test ! -z $2 ; then
        REX=49
    fi
    write_u16 d1 $REX
    write_b8 "11100${1}"
}

shr_u64_imm8 () {
    REX=48
    if test ! -z $3 ; then
        REX=49
    fi
    write_u16 c1 $REX
    write_b8 "11101${1}"
    write_u8 $2
}
shr_u64_once () {
    REX=48
    if test ! -z $2 ; then
        REX=49
    fi
    write_u16 d1 $REX
    write_b8 "11111${1}"
}

syscall () { 
    write_u16 05 0f
}

xor_self_u32 () {
    if test ! -z $2 ; then
        write_u8 45
    fi
    write_u8 33
    write_b8 "11${1}${1}"
}

write_ph () {
    # PROGRAM header
    ####################
    write_u32 00 00 00 01                # p_type        | program type load 
    write_u32 00 00 00 07                # p_flags       | program flags set to read, write and executable
    write_u64 00 00 00 00 00 00 00 00    # p_offset      | when does the segment start -> elf + program header
    write_u64 00 00 00 00 00 40 00 00    # p_vaddr       | virtual base address
    write_zeroes 8                       # p_paddr       | ignored on my system

    hex=$(printf '%016x' $1)
    # p_filesz      | accumulated bytes of the instructions
    write_u64 "${hex:0:2}" "${hex:2:2}" "${hex:4:2}" "${hex:6:2}" "${hex:8:2}" "${hex:10:2}" "${hex:12:2}" "${hex:14:2}"
    # p_memsz       | do not allocate more memory in the image than instructions
    write_u64 "${hex:0:2}" "${hex:2:2}" "${hex:4:2}" "${hex:6:2}" "${hex:8:2}" "${hex:10:2}" "${hex:12:2}" "${hex:14:2}"

    write_u64 00 00 00 00 00 00 00 00    # p_align       | has something to do with v_addr and p_offset 
}

write_elf () {

# ELF header
###############
write_u32 46 4c 45 7f                # elf identifier
write_u8 02                          # class         | 64 bit
write_u8 01                          # data encoding | lsb
write_u8 01                          # file version  | 1 current
write_u8 03                          # operating system/ABI identification
write_u8 00                          # ABI version   | 0 - no features
write_zeroes 7                       # padding

write_u16 00 02                      # e_type        | exe
write_u16 00 3e                      # e_machine     | AMD
write_u32 00 00 00 01                # e_version     | current
write_u64 00 00 00 00 00 40 00 78    # e_entry       | set virtual base address
write_u64 00 00 00 00 00 00 00 40    # e_ph_off      | program header immediatle after the elf header
write_zeroes 8                       # e_shoff       | no section headers
write_zeroes 4                       # e_flags       | no flags
write_u16 00 40                      # e_h_size      | elf header size
write_u16 00 38                      # e_ph_ent_size | size of program headers
write_u16 00 01                      # e_ph_num      | number of program headers 
write_zeroes 2                       # e_shentsize   | not used.
write_zeroes 2                       # e_shnum       | not used.
write_zeroes 2                       # e_shstrndx    | not used.

}

write_ins () {

# Instructions
################

# PROGRAM RETURN CODES
# 1         - no file provided
# 2         - unable to read file
# 3         - invalid token encountered

# .begin
# jump to entry
jmp_imm32 00 00 02 14 # >entry

# helper functions

# .allocate
# args:
#   rdi | addr -> always null ig? so gets cleared
#   rsi | len  -> expected to be set
#   rdx | protection get set by func
#   r10 | flags      get set by func
#   r8  | fd         no file mapping so -1
#   r9  | pgoff     idk 0
xor_self_u32 $di
add_u32_imm32 $si 00 00 0f ff
and_u32_imm32 $si ff ff f0 00
mov_u32_imm32 $dx 00 00 00 03
mov_u32_imm32 $r10 00 00 00 22 0
mov_u32_imm32 $r8 ff ff ff ff 0
xor_self_u32 $r9 0
mov_u32_imm32 $ax 00 00 00 09
syscall
ret

# TODO: use conditional moves instead of branches for ident detection

# .is_ident_start
# args:
#   rdi | char
# return:
#   rax | bool
xor_self_u32 $ax
# if chr is underscore 
cmp_u32_imm8 $di 5f # '_'
jcc_q_imm8 14 # >is_ident_start_true
# if chr is upper case roman literal
cmp_u32_imm8 $di 41 # 'A'
jcc_l_imm8 11 # >is_ident_start_ret
cmp_u32_imm8 $di 5a # 'Z'
jcc_lq_imm8 0a # >is_ident_start_true
# if chr is lower case roman literal
cmp_u32_imm8 $di 61 # 'a'
jcc_l_imm8 07 # >is_ident_start_ret
cmp_u32_imm8 $di 7a # 'z'
jcc_g_imm8 02 # >is_ident_start_ret
# .is_ident_start_true
inc_u32 $ax
# .is_ident_start_ret
ret

# .is_ident
# args:
#   rdi | char
# return:
#   rax | bool
xor_self_u32 $ax
call_imm32 ff ff ff db  # >is_ident_start
cmp_u32_imm8 $ax 01
jcc_q_imm8 0c           # >is_ident_ret

# if chr is a number
cmp_u32_imm8 $di 30
jcc_l_imm8 07           # >is_ident_ret
cmp_u32_imm8 $di 39 
jcc_g_imm8 02           # >is_ident_ret

# .is_ident_true
inc_u32 $ax
# .is_ident_ret
ret

# .is_number
# args:
#   rdi | char
# return:
#   rax | bool
xor_self_u32 $ax
cmp_u32_imm8 $di 30
jcc_l_imm8 07 # >is_number_ret
cmp_u32_imm8 $di 39
jcc_g_imm8 02 # >is_number_ret

inc_u32 $ax
# .is_number_ret
ret

# .next_token
# args:
#   r12     | file
#   r13     | size
#   r14     | pos
#   r15     | line
# modify: rax, rdi, rsi
# return:
#   rax | TOKEN.token_kind
#   rsi | TOKEN.beg

cmp_u64_u64 $r13 $r14 2
jcc_g_imm8 0e                   # >next_token_begin

mov_u32_imm32 $ax 00 00 00 50   # TOKEN.token_kind [80] EOF
mov_u64_u64 $si $r14 1
jmp_imm32 00 00 01 8c           # >next_token_return

# .next_token_begin
jmp_imm8 03             

# .next_token_skip_whitespace_newline_and_tabs_beg
inc_u64 $r14 0

# while ch == '\n' or ch == ' ' or ch == '\t' {
#   if ch == '\n' {
#       line += 1;
#   }
#   pos += 1;
#   ch = arr[pos];
# }

lea_u64_ea_u64_disp8 $si $r15 01 1
xor_self_u32 $ax
movzx_u32_ea_byte_ptr_u64_base_u64 $di $r12 $r14 "12"
cmp_u32_imm8 $di 0a
cmovq_u32_u32 $ax $si
cmovq_u32_u32 $r15 $si 0
cmp_u32_imm8 $di 20
cmovq_u32_u32 $ax $si
cmp_u32_imm8 $di 09
cmovq_u32_u32 $ax $si
cmp_u32_u32 $ax $si
jcc_q_imm32 ff ff ff d4 # >next_token_skip_whitespace_newline_and_tabs_beg

mov_u64_u64 $si $r14 1  # rsi = TOKEN.beg

call_imm32 ff ff ff 71  # >is_ident_start
cmp_u32_imm8 $ax 01
jcc_nq_imm8 19          # >next_token_check_number

# .next_token_iterate_ident
inc_u64 $r14 0
movzx_u32_ea_byte_ptr_u64_base_u64 $di $r12 $r14 "12"
call_imm32 ff ff ff 7d  # >is_ident
cmp_u32_imm8 $ax 01
jcc_q_imm8 ee           # >next_token_iterate_ident
# .next_token_iterate_ident_end

xor_self_u32 $ax        # rax = TOKEN.token_kind [0] = ident
jmp_imm32 00 00 01 38   # >next_token_return

# .next_token_check_number

call_imm32 ff ff ff 85  # >is_number
cmp_u32_imm8 $ax 01
jcc_nq_imm8 1d          # >next_token_check_single_chars

# .next_token_iterate_number
inc_u64 $r14 0
movzx_u32_ea_byte_ptr_u64_base_u64 $di $r12 $r14 "12"
call_imm32 ff ff ff 73  # >is_number
cmp_u32_imm8 $ax 01
jcc_q_imm8 ee           # >next_token_iterate_number
# .next_token_iterate_number_end

mov_u32_imm32 $ax 00 00 00 01
jmp_imm32 00 00 01 11   # >next_token_return

# .next_token_check_single_chars

# TODO: most compilers could probably optimize this into 
# something very neat but I am only a human after all...

# TOK_L_PAREN [21] '('
cmp_u32_imm8 $di 28
jcc_nq_imm8 0b          # >next_token_check_TOK_R_PAREN
mov_u32_imm32 $ax 00 00 00 15
jmp_imm32 00 00 00 fe   # >next_token_advance

# TOK_R_PAREN [22] ')'
# .next_token_check_TOK_R_PAREN
cmp_u32_imm8 $di 29
jcc_nq_imm8 0b          # >next_token_check_TOK_L_BRACE
mov_u32_imm32 $ax 00 00 00 16
jmp_imm32 00 00 00 ee   # >next_token_advance

# TOK_L_BRACE [23] '{'
# .next_token_check_TOK_L_BRACE
cmp_u32_imm8 $di 7b
jcc_nq_imm8 0b          # >next_token_check_TOK_R_BRACE
mov_u32_imm32 $ax 00 00 00 17
jmp_imm32 00 00 00 de   # >next_token_advance

# TOK_R_BRACE [24] '}'
# .next_token_check_TOK_R_BRACE
cmp_u32_imm8 $di 7d
jcc_nq_imm8 0b          # >next_token_check_TOK_L_BRACKET
mov_u32_imm32 $ax 00 00 00 18
jmp_imm32 00 00 00 ce   # >next_token_advance

# TOK_L_BRACKET [25] '['
# .next_token_check_TOK_L_BRACKET
cmp_u32_imm8 $di 5b
jcc_nq_imm8 0b          # >next_token_check_TOK_R_BRACKET
mov_u32_imm32 $ax 00 00 00 19
jmp_imm32 00 00 00 be   # >next_token_advance

# TOK_R_BRACKET [26] ']'
# .next_token_check_TOK_R_BRACKET
cmp_u32_imm8 $di 5d
jcc_nq_imm8 0b          # >next_token_check_TOK_STAR
mov_u32_imm32 $ax 00 00 00 1a
jmp_imm32 00 00 00 ae   # >next_token_advance

# TOK_STAR  [27] '*'
# .next_token_check_TOK_STAR
cmp_u32_imm8 $di 2a
jcc_nq_imm8 0b          # >next_token_check_TOK_ROOF
mov_u32_imm32 $ax 00 00 00 1b
jmp_imm32 00 00 00 9e   # >next_token_advance

# TOK_ROOF  [28] '^'
# .next_token_check_TOK_ROOF
cmp_u32_imm8 $di 5e
jcc_nq_imm8 0b          # >next_token_check_TOK_EQUAL
mov_u32_imm32 $ax 00 00 00 1c
jmp_imm32 00 00 00 8e   # >next_token_advance

# TOK_EQUAL  [29] '='
# .next_token_check_TOK_EQUAL
cmp_u32_imm8 $di 3d
jcc_nq_imm8 0b          # >next_token_check_TOK_COMMA
mov_u32_imm32 $ax 00 00 00 1d
jmp_imm32 00 00 00 7e   # >next_token_advance

# TOK_COMMA  [30] ','
# .next_token_check_TOK_COMMA
cmp_u32_imm8 $di 2c
jcc_nq_imm8 0b          # >next_token_check_TOK_SEMICOLON
mov_u32_imm32 $ax 00 00 00 1e
jmp_imm32 00 00 00 6e   # >next_token_advance

# TOK_SEMICOLON  [31] ';'
# .next_token_check_TOK_SEMICOLON
cmp_u32_imm8 $di 3b
jcc_nq_imm8 0b          # >next_token_check_TOK_HASHTAG
mov_u32_imm32 $ax 00 00 00 1f
jmp_imm32 00 00 00 5e   # >next_token_advance

# TOK_HASHTAG  [32] '#'
# .next_token_check_TOK_HASHTAG
cmp_u32_imm8 $di 23
jcc_nq_imm8 0b          # >next_token_check_TOK_PLUS
mov_u32_imm32 $ax 00 00 00 20
jmp_imm32 00 00 00 4e   # >next_token_advance

# TOK_PLUS  [33] '+'
# .next_token_check_TOK_PLUS
cmp_u32_imm8 $di 2b
jcc_nq_imm8 0b          # >next_token_check_TOK_MINUS
mov_u32_imm32 $ax 00 00 00 21
jmp_imm32 00 00 00 3e   # >next_token_advance

# TOK_MINUS  [34] '-'
# .next_token_check_TOK_MINUS
cmp_u32_imm8 $di 2d
jcc_nq_imm8 0b          # >next_token_check_TOK_SLASH
mov_u32_imm32 $ax 00 00 00 22
jmp_imm32 00 00 00 2e   # >next_token_advance

# TOK_SLASH  [35] '/'
# .next_token_check_TOK_SLASH
cmp_u32_imm8 $di 2f
jcc_nq_imm8 0b          # >next_token_check_TOK_DOT
mov_u32_imm32 $ax 00 00 00 23
jmp_imm32 00 00 00 1e   # >next_token_advance

# TOK_DOT  [36] '.'
# .next_token_check_TOK_DOT
cmp_u32_imm8 $di 2e
jcc_nq_imm8 0b          # >next_token_invalid_token
mov_u32_imm32 $ax 00 00 00 24
jmp_imm32 00 00 00 0e   # >next_token_advance

# .next_token_invalid_token
mov_u32_imm32 $di 00 00 00 03
mov_u32_imm32 $ax 00 00 00 3c
syscall

# .next_token_advance
inc_u64 $r14 0

# .next_token_return
ret

# ======= MAIN ================================

# .entry
# args:
#   rsp | holds argc, argv and environ probably

mov_u64_ea_u64 $di $sp              # argc
cmp_u32_imm8 $di 02
jcc_q_imm8 0e
# TODO: error no file provided
mov_u32_imm32 $di 00 00 00 01
mov_u32_imm32 $ax 00 00 00 3c
syscall

# get file descriptor
mov_u32_imm32 $ax 00 00 00 02

mov_u64_ea_u64_disp8 $di $sp 10     # argv[1]
mov_u64_imm64 $si 00 00 00 00 00 00 00 02
mov_u64_imm64 $dx 00 00 00 00 00 00 01 a4
syscall

cmp_u32_imm8 $ax 00
jcc_ns_imm8 0e
# TODO: error unable to read file
mov_u32_imm32 $di 00 00 00 02
mov_u32_imm32 $ax 00 00 00 3c
syscall

mov_u64_u64 $r14 $ax 0  # fd

# get file size
mov_u64_u64 $di $ax
xor_self_u32 $si
mov_u32_imm32 $dx 00 00 00 02
mov_u32_imm32 $ax 00 00 00 08
syscall

mov_u64_u64 $r13 $ax 0  # file_size

mov_u64_u64 $di $r14 1
xor_self_u32 $si
xor_self_u32 $dx
mov_u32_imm32 $ax 00 00 00 08
syscall

# allocate file size aligned to page size
mov_u32_u32 $si $r13 1
call_imm32 ff ff fd 71  # >allocate
mov_u64_u64 $r12 $ax 0  # r12 file_ptr

# read file
mov_u64_u64 $di $r14 1
mov_u64_u64 $si $ax
mov_u64_u64 $dx $r13 1
xor_self_u32 $ax
syscall

# close file
mov_u64_u64 $di $r14 1
mov_u32_imm32 $ax 00 00 00 03
syscall

# enum TokenKind [u32] {
#   ident       = 0         '__hellow_16'
#   number      = 1         '112233'
#
#   TOK_L_PAREN     = 21    '('
#   TOK_R_PAREN     = 22    ')'
#   TOK_L_BRACE     = 23    '{'
#   TOK_R_BRACE     = 24    '}'
#   TOK_L_BRACKET   = 25    '['
#   TOK_R_BRACKET   = 26    ']'
#   TOK_STAR        = 27    '*'
#   TOK_ROOF        = 28    '^'
#   TOK_EQUAL       = 29    '='
#   TOK_COMMA       = 30    ','
#   TOK_SEMICOLON   = 31    ';'
#   TOK_HASHTAG     = 32    '#'
#   TOK_PLUS        = 33    '+'
#   TOK_MINUS       = 34    '-'
#   TOK_SLASH       = 35    '/'
#   TOK_DOT         = 36    '.'
#   
#   TODO: thinking about adding token types for //
#
#   KW_if       = 40        'if'
#   KW_while    = 41        'while'
#   WK_return   = 42        'return'
#
#   Type_s8     = 60        's8'
#   Type_s16    = 61        's16'
#   Type_s32    = 62        's32'
#   Type_s64    = 63        's64'
#
#   EOF         = 80
# };
#
# struct Token [u64] {
#   TokenKind kind;     | rax
#   u32 file_offset;    | rsi
# };

# ============== ELF_HEADER ============================

# mov_u64_u64 $si $r13 1
# shl_u64_imm8 $si 04
# call_imm32 ff ff fd 2c # >allocate

# xor_edi_edi
# mov_ea_rax_base_rdi_imm64

# ============== PARSING / CODE_GEN ====================

xor_self_u32 $r14 1             # current offset in the file
xor_self_u32 $r15 1             # current line   in the file

# struct Var  {
#   u64     flags;
#   // 1    = is_ptr 
#   // 2    = is_arr
#   // 4    = is_non
#   // 8    = is_prm
#   // 32.. = array_len
#   Token   type;
#   Token   ident;
# }
# struct Func {
#   Var     *args;
#   u64     len;
#   u64     cap;
#   u64     byte_offset;
#   Var     return_type;
# }
#
# do {
#   iden = next_token
#   assert iden.kind == ident
#
#   next = next_token
#   if next.kind == L_PAREN {
#       parse_arguments
#       parse_body
#   } else if next.kind == L_BRACE {
#
#   } else {
#       error : expected l_paren or l_brace but got x on line y
#   }
# } while token.kind != EOF

call_imm32 ff ff fd bf      # >next_token

mov_u64_u64 $di $ax
mov_u32_imm32 $ax 00 00 00 3c
syscall

# .shell_script_write_final_output

lea_u64_ea_u64_base_u64 $ax $di $cx
lea_u64_ea_u64_base_u64 $ax $r8 $r15 "12"

}

write_elf >> $FILE
SIZE=0
INS="$(mktemp)"

write_ins > $INS
write_ph $SIZE >> $FILE
cat $INS >> $FILE

ndisasm -ab64 $INS

chmod +x $FILE
./$FILE $EXPL

