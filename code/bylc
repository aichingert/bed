#!/usr/bin/sh

# x86-64 instructions: https://www.felixcloutier.com/x86/
# more reading: https://wiki.osdev.org/X86-64_Instruction_Encoding
#             - https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
#             /r                -> reg and r/m operand
#             ib, iw, id, io    -> immediate value byte size 1, 2, 4, 8
#             +rb, +rw, +rd +ro -> lower 3 opcode bits encode register

# ea -> effective memory address
set -e

FILE="byl"
EXPL="../test/test_only_entry_fn.byl"
INST="$(date +%s)"
BUFF=$FILE
SIZE=0

ax="000"
cx="001"
dx="010"
bx="011"
sp="100"
bp="101"
si="110"
di="111"
r8="000"
r9="001"
r10="010"
r11="011"
r12="100"
r13="101"
r14="110"
r15="111"

if test -e "$FILE" ; then
    rm "$FILE"
fi

write_zeroes () {
    for i in $(seq 1 "$1") ; do
        SIZE=$(expr $SIZE + 1)
        printf '\x00' >> $BUFF
    done
}

write_bits_8 () {
    SIZE=$(expr $SIZE + 1)
    printf "\\$(printf '%o' "$((2#$1))")" >> $BUFF
}

write_u8  () {
    SIZE=$(expr $SIZE + 1)
    printf "\x$1" >> "$BUFF"
}

write_u16 () {
    write_u8 $2
    write_u8 $1
}

write_u32 () {
    write_u16 $3 $4
    write_u16 $1 $2
}

write_u64 () {
    write_u32 $5 $6 $7 $8
    write_u32 $1 $2 $3 $4
}

push_u64 () {
    REX=48
    if test ! -z $2 ; then 
        REX=$(expr $REX + $2)
    fi
    write_u8 $REX
    write_u8 ff
    write_bits_8 "11110${1}"
}

pop_u64 () {
    REX=48
    if test ! -z $2 ; then 
        REX=$(expr $REX + $2)
    fi
    write_u8 $REX
    write_u8 8f
    write_bits_8 "11000${1}"
}

neg_u64 () {
    REX=48
    if test ! -z $2 ; then
        REX=$(expr $REX + $2)
    fi
    write_u8 $REX
    write_u8 f7
    write_bits_8 "11011${1}"
}

shl_u64_imm8 () {
    REX=48
    if test ! -z $3 ; then
        REX=$(expr $REX + $3)
    fi
    write_u8 $REX
    write_u8 c1
    write_bits_8 "11100${1}"
    write_u8 $2
}

shr_u64_imm8 () {
    REX=48
    if test ! -z $3 ; then
        REX=$(expr $REX + $3)
    fi
    write_u8 $REX
    write_u8 c1
    write_bits_8 "11101${1}"
    write_u8 $2
}

shl_u64_once () {
    REX=48
    if test ! -z $2 ; then
        REX=$(expr $REX + $2)
    fi
    write_u8 $REX
    write_u8 d1
    write_bits_8 "11100${1}"
}

shr_u64_once () {
    REX=48
    if test ! -z $2 ; then
        REX=$(expr $REX + $2)
    fi
    write_u8 $REX
    write_u8 d1
    write_bits_8 "11111${1}"
}

add_u32_imm8 () {
    if test ! -z $3 ; then
        write_u8 41
    fi
    write_u8 83
    write_bits_8 "11000${1}"
    write_u8 $2
}

add_u32_imm32 () {
    if test ! -z $6 ; then
        write_u8 41
    fi
    write_u8 81
    write_bits_8 "11000${1}"
    write_u32 $2 $3 $4 $5
}

add_u64_imm32 () {
    REX=48
    if test ! -z $6 ; then
        REX=$(expr $REX + $6)
    fi
    write_u8 $REX
    write_u8 81
    write_bits_8 "11000${1}"
    write_u32 $2 $3 $4 $5
}

and_u32_imm32 () {
    if test ! -z $6 ; then
        write_u8 41
    fi
    write_u8 81
    write_bits_8 "11100${1}"
    write_u32 $2 $3 $4 $5
}

and_u64_imm32 () {
    REX=48
    if test ! -z $6 ; then
        REX=$(expr $REX + $6)
    fi
    write_u8 $REX
    write_u8 81
    write_bits_8 "11100${1}"
    write_u32 $2 $3 $4 $5
}

mov_u32_imm32 () {
    if test ! -z $6 ; then
        write_u8 41
    fi
    write_u8 c7
    write_bits_8 "11000${1}"
    write_u32 $2 $3 $4 $5
}

mov_u32_u32 () {
    if test ! -z $3 ; then
        REX=41
        REX=$(expr $REX + $3)
        write_u8 $REX
    fi
    write_u8 8b
    write_bits_8 "11${1}${2}"
}

mov_u64_u64 () {
    REX=48
    if test ! -z $3 ; then
        if test $3 -eq "0" ; then
            REX="49"
        else
            REX="4c"
        fi
    fi
    write_u8 $REX
    write_u8 8b
    write_bits_8 "11${1}${2}"
}

mov_rsi_imm64 () {
    write_u8 48
    write_bits_8 10111110
    write_u64 $1 $2 $3 $4 $5 $6 $7 $8
}

xor_self_u32 () {
    if test ! -z $2 ; then
        write_u8 45
    fi
    write_u8 33
    write_bits_8 "11${1}${1}"
}

mov_rdx_imm64 () {
    write_u8 48
    write_bits_8 10111010
    write_u64 $1 $2 $3 $4 $5 $6 $7 $8
}

mov_rax_ea_r14 () {
    write_u8 49
    write_u8 8b
    write_bits_8 00000110
}

mov_rdi_ea_r14 () {
    write_u8 49
    write_u8 8b
    write_bits_8 00111110
}

mov_rax_ea_rcx_disp32 () {
    write_u8 48
    write_u8 0f
    write_u8 b6
    write_bits_8 10000001
    write_u32 $1 $2 $3 $4
}

movzx_eax_ea_r12_base_rbx () {
    write_u8 41
    write_u8 0f
    write_u8 b6
    write_bits_8 00000100
    write_bits_8 00011100
}
movzx_esi_ea_r12_base_rbx () {
    write_u8 41
    write_u8 0f
    write_u8 b6
    write_bits_8 00110100
    write_bits_8 00011100
}
movzx_edi_ea_rcx_base_rax () {
    write_u8 48
    write_u8 0f
    write_u8 b6
    write_bits_8 00111100
    write_bits_8 00000001
}
movzx_edi_ea_r12_base_r14 () {
    write_u8 43
    write_u8 0f
    write_u8 b6
    write_bits_8 00111100
    write_bits_8 00110100
}

mov_rdi_ea_rcx () {
    write_u8 48
    write_u8 8b
    write_bits_8 00111001
}

mov_rdi_ea_rsp_disp8 () {
    write_u8 48
    write_u8 8b
    write_bits_8 01111100
    write_bits_8 01100100
    write_u8 $1
}
mov_rax_ea_rsp_disp8 () {
    write_u8 48
    write_u8 8b
    write_bits_8 01000100
    write_bits_8 01100100
    write_u8 $1
}
mov_rcx_ea_rsp_disp8 () {
    write_u8 48
    write_u8 8b
    write_bits_8 01001100
    write_bits_8 01100100
    write_u8 $1
}

cmovq_eax_esi () {
    write_u8 0f
    write_u8 44
    write_bits_8 11000110
}
cmovq_eax_edi () {
    write_u8 0f
    write_u8 44
    write_bits_8 11000111
}
cmovq_r15d_esi () {
    write_u8 44
    write_u8 0f
    write_u8 44
    write_bits_8 11111110
}

cmp_edi_imm8 () {
    write_u8 83
    write_bits_8 11111111
    write_u8 $1
}
cmp_rdi_imm8 () {
    write_u8 48
    write_u8 83
    write_bits_8 11111111
    write_u8 $1
}
cmp_eax_imm8 () {
    write_u8 83
    write_bits_8 11111000
    write_u8 $1
}
cmp_ebx_imm8 () {
    write_u8 83
    write_bits_8 11111011
    write_u8 $1
}
cmp_eax_edi () {
    write_u8 3b
    write_bits_8 11000111
}
cmp_eax_esi () {
    write_u8 3b
    write_bits_8 11000110
}
cmp_ebx_r13d () {
    write_u8 41
    write_u8 3b
    write_bits_8 11011101
}
cmp_r13_r14 () {
    write_u8 4d
    write_u8 3b
    write_bits_8 11101110
}
cmp_rdi_rsi () {
    write_u8 48
    write_u8 39
    write_bits_8 11110111
}
cmp_rdx_r15 () {
    write_u8 49
    write_u8 3b
    write_bits_8 11010111
}
cmp_rax_imm8 () {
    write_u8 48
    write_u8 83
    write_bits_8 11111000
    write_u8 $1
}

lea_rax_rcx () {
    write_u8 48
    write_u8 8d
    write_bits_8 00000001
}
lea_rsi_r14_disp8 () {
    write_u8 49
    write_u8 8d
    write_bits_8 01110110
    write_u8 $1
}
lea_rsi_r15_disp8 () {
    write_u8 49
    write_u8 8d
    write_bits_8 01110111
    write_u8 $1
}
lea_rsi_r12_base_rbx () {
    write_u8 49
    write_u8 8d
    write_bits_8 00110100
    write_bits_8 00011100
}

jcc_s_imm8 () {
    write_u8 78
    write_u8 $1
}
jcc_ns_imm8 () {
    write_u8 79
    write_u8 $1
}
jcc_g_imm8 () {
    write_u8 7f
    write_u8 $1
}
jcc_gq_imm8 () {
    write_u8 73
    write_u8 $1
}
jcc_q_imm8 () {
    write_u8 74
    write_u8 $1
}
jcc_q_imm32 () {
    write_u8 0f
    write_u8 84
    write_u32 $1 $2 $3 $4
}
jcc_nq_imm8 () {
    write_u8 75
    write_u8 $1
}
jcc_l_imm8 () {
    write_u8 72
    write_u8 $1
}
jcc_lq_imm8 () {
    write_u8 76
    write_u8 $1
}

jmp_imm8 () {
    write_u8 eb
    write_u8 $1
}
jmp_imm32 () {
    write_u8 e9
    write_u32 $1 $2 $3 $4
}

inc_eax () {
    write_u8 ff
    write_bits_8 11000000
}
inc_rax () {
    write_u8 48
    write_u8 ff
    write_bits_8 11000000
}
inc_rcx () {
    write_u8 48
    write_u8 ff
    write_bits_8 11000001
}
inc_rdx () {
    write_u8 48
    write_u8 ff
    write_bits_8 11000010
}
inc_r14 () {
    write_u8 49
    write_u8 ff
    write_bits_8 11000110
}
inc_r15 () {
    write_u8 49
    write_u8 ff
    write_bits_8 11000111
}

inc_ebx () {
    write_u8 ff
    write_bits_8 11000011
}

ret () {
    write_u8 c3
}

call_imm32 () {
    write_u8 e8
    write_u32 $1 $2 $3 $4
}

syscall () {
    write_u16 05 0f
}

write_ph () {
    # PROGRAM header
    ####################
    write_u32 00 00 00 01                # p_type        | program type load 
    write_u32 00 00 00 07                # p_flags       | program flags set to read, write and executable
    write_u64 00 00 00 00 00 00 00 00    # p_offset      | when does the segment start -> elf + program header
    write_u64 00 00 00 00 00 40 00 00    # p_vaddr       | virtual base address
    write_zeroes 8                       # p_paddr       | ignored on my system

    hex=$(printf '%016x' $1)
    # p_filesz      | accumulated bytes of the instructions
    write_u64 "${hex:0:2}" "${hex:2:2}" "${hex:4:2}" "${hex:6:2}" "${hex:8:2}" "${hex:10:2}" "${hex:12:2}" "${hex:14:2}"
    # p_memsz       | do not allocate more memory in the image than instructions
    write_u64 "${hex:0:2}" "${hex:2:2}" "${hex:4:2}" "${hex:6:2}" "${hex:8:2}" "${hex:10:2}" "${hex:12:2}" "${hex:14:2}"

    write_u64 00 00 00 00 00 00 00 00    # p_align       | has something to do with v_addr and p_offset 
}

# ELF header
###############
write_u32 46 4c 45 7f                # elf identifier
write_u8 02                          # class         | 64 bit
write_u8 01                          # data encoding | lsb
write_u8 01                          # file version  | 1 current
write_u8 03                          # operating system/ABI identification
write_u8 00                          # ABI version   | 0 - no features
write_zeroes 7                       # padding

write_u16 00 02                      # e_type        | exe
write_u16 00 3e                      # e_machine     | AMD
write_u32 00 00 00 01                # e_version     | current
write_u64 00 00 00 00 00 40 00 78    # e_entry       | set virtual base address
write_u64 00 00 00 00 00 00 00 40    # e_ph_off      | program header immediatle after the elf header
write_zeroes 8                       # e_shoff       | no section headers
write_zeroes 4                       # e_flags       | no flags
write_u16 00 40                      # e_h_size      | elf header size
write_u16 00 38                      # e_ph_ent_size | size of program headers
write_u16 00 01                      # e_ph_num      | number of program headers 
write_zeroes 2                       # e_shentsize   | not used.
write_zeroes 2                       # e_shnum       | not used.
write_zeroes 2                       # e_shstrndx    | not used.

SIZE=0
BUFF=$INST

# Instructions
################

# PROGRAM RETURN CODES
# 1         - no file provided
# 2         - unable to read file
# 3         - invalid token encountered

# .begin
# jump to entry
jmp_imm32 00 00 02 14 # >entry

# helper functions

# .allocate
# args:
#   rdi | addr -> always null ig? so gets cleared
#   rsi | len  -> expected to be set
#   rdx | protection get set by func
#   r10 | flags      get set by func
#   r8  | fd         no file mapping so -1
#   r9  | pgoff     idk 0
xor_self_u32 $di
add_u32_imm32 $si 00 00 0f ff
and_u32_imm32 $si ff ff f0 00
mov_u32_imm32 $dx 00 00 00 03
mov_u32_imm32 $r10 00 00 00 22 0
mov_u32_imm32 $r8 ff ff ff ff 0
xor_self_u32 $r9 0
mov_u32_imm32 $ax 00 00 00 09
syscall
ret

# TODO: use conditional moves instead of branches for ident detection

# .is_ident_start
# args:
#   rdi | char
# return:
#   rax | bool
xor_self_u32 $ax
# if chr is underscore 
cmp_edi_imm8 5f # '_'
jcc_q_imm8 14 # >is_ident_start_true
# if chr is upper case roman literal
cmp_edi_imm8 41 # 'A'
jcc_l_imm8 11 # >is_ident_start_ret
cmp_edi_imm8 5a # 'Z'
jcc_lq_imm8 0a # >is_ident_start_true
# if chr is lower case roman literal
cmp_edi_imm8 61 # 'a'
jcc_l_imm8 07 # >is_ident_start_ret
cmp_edi_imm8 7a # 'z'
jcc_g_imm8 02 # >is_ident_start_ret
# .is_ident_start_true
inc_eax
# .is_ident_start_ret
ret

# .is_ident
# args:
#   rdi | char
# return:
#   rax | bool
xor_self_u32 $ax
call_imm32 ff ff ff db  # >is_ident_start
cmp_eax_imm8 01
jcc_q_imm8 0c           # >is_ident_ret

# if chr is a number
cmp_edi_imm8 30
jcc_l_imm8 07           # >is_ident_ret
cmp_edi_imm8 39 
jcc_g_imm8 02           # >is_ident_ret

# .is_ident_true
inc_eax
# .is_ident_ret
ret

# .is_number
# args:
#   rdi | char
# return:
#   rax | bool
xor_self_u32 $ax
cmp_edi_imm8 30
jcc_l_imm8 07 # >is_number_ret
cmp_edi_imm8 39
jcc_g_imm8 02 # >is_number_ret

inc_eax
# .is_number_ret
ret

# .next_token
# args:
#   r12     | file
#   r13     | size
#   r14     | pos
#   r15     | line
# modify: rax, rdi, rsi
# return:
#   rax | TOKEN.token_kind
#   rsi | TOKEN.beg

cmp_r13_r14
jcc_l_imm8 0e                   # >next_token_begin

mov_u32_imm32 $ax 00 00 00 50   # TOKEN.token_kind [80] EOF
mov_u64_u64 $si $r14 0
jmp_imm32 00 00 01 8c           # >next_token_return

# .next_token_begin
jmp_imm8 03             

# .next_token_skip_whitespace_newline_and_tabs_beg
inc_r14

# while ch == '\n' or ch == ' ' or ch == '\t' {
#   if ch == '\n' {
#       line += 1;
#   }
#   pos += 1;
#   ch = arr[pos];
# }

lea_rsi_r15_disp8 01
xor_self_u32 $ax
movzx_edi_ea_r12_base_r14
cmp_edi_imm8 0a
cmovq_eax_esi
cmovq_r15d_esi
cmp_edi_imm8 20
cmovq_eax_esi
cmp_edi_imm8 09
cmovq_eax_esi
cmp_eax_esi
jcc_q_imm32 ff ff ff d4 # >next_token_skip_whitespace_newline_and_tabs_beg

mov_u64_u64 $si $r14 0  # rsi = TOKEN.beg

call_imm32 ff ff ff 71  # >is_ident_start
cmp_eax_imm8 01
jcc_nq_imm8 19          # >next_token_check_number

# .next_token_iterate_ident
inc_r14
movzx_edi_ea_r12_base_r14
call_imm32 ff ff ff 7d  # >is_ident
cmp_eax_imm8 01
jcc_q_imm8 ee           # >next_token_iterate_ident
# .next_token_iterate_ident_end

xor_self_u32 $ax        # rax = TOKEN.token_kind [0] = ident
jmp_imm32 00 00 01 38   # >next_token_return

# .next_token_check_number

call_imm32 ff ff ff 85  # >is_number
cmp_eax_imm8 01
jcc_nq_imm8 1d          # >next_token_check_single_chars

# .next_token_iterate_number
inc_r14
movzx_edi_ea_r12_base_r14
call_imm32 ff ff ff 73  # >is_number
cmp_eax_imm8 01
jcc_q_imm8 ee           # >next_token_iterate_number
# .next_token_iterate_number_end

mov_u32_imm32 $ax 00 00 00 01
jmp_imm32 00 00 01 11   # >next_token_return

# .next_token_check_single_chars

# TODO: most compilers could probably optimize this into 
# something very neat but I am only a human after all...

# TOK_L_PAREN [21] '('
cmp_edi_imm8 28
jcc_nq_imm8 0b          # >next_token_check_TOK_R_PAREN
mov_u32_imm32 $ax 00 00 00 15
jmp_imm32 00 00 00 fe   # >next_token_advance

# TOK_R_PAREN [22] ')'
# .next_token_check_TOK_R_PAREN
cmp_edi_imm8 29
jcc_nq_imm8 0b          # >next_token_check_TOK_L_BRACE
mov_u32_imm32 $ax 00 00 00 16
jmp_imm32 00 00 00 ee   # >next_token_advance

# TOK_L_BRACE [23] '{'
# .next_token_check_TOK_L_BRACE
cmp_edi_imm8 7b
jcc_nq_imm8 0b          # >next_token_check_TOK_R_BRACE
mov_u32_imm32 $ax 00 00 00 17
jmp_imm32 00 00 00 de   # >next_token_advance

# TOK_R_BRACE [24] '}'
# .next_token_check_TOK_R_BRACE
cmp_edi_imm8 7d
jcc_nq_imm8 0b          # >next_token_check_TOK_L_BRACKET
mov_u32_imm32 $ax 00 00 00 18
jmp_imm32 00 00 00 ce   # >next_token_advance

# TOK_L_BRACKET [25] '['
# .next_token_check_TOK_L_BRACKET
cmp_edi_imm8 5b
jcc_nq_imm8 0b          # >next_token_check_TOK_R_BRACKET
mov_u32_imm32 $ax 00 00 00 19
jmp_imm32 00 00 00 be   # >next_token_advance

# TOK_R_BRACKET [26] ']'
# .next_token_check_TOK_R_BRACKET
cmp_edi_imm8 5d
jcc_nq_imm8 0b          # >next_token_check_TOK_STAR
mov_u32_imm32 $ax 00 00 00 1a
jmp_imm32 00 00 00 ae   # >next_token_advance

# TOK_STAR  [27] '*'
# .next_token_check_TOK_STAR
cmp_edi_imm8 2a
jcc_nq_imm8 0b          # >next_token_check_TOK_ROOF
mov_u32_imm32 $ax 00 00 00 1b
jmp_imm32 00 00 00 9e   # >next_token_advance

# TOK_ROOF  [28] '^'
# .next_token_check_TOK_ROOF
cmp_edi_imm8 5e
jcc_nq_imm8 0b          # >next_token_check_TOK_EQUAL
mov_u32_imm32 $ax 00 00 00 1c
jmp_imm32 00 00 00 8e   # >next_token_advance

# TOK_EQUAL  [29] '='
# .next_token_check_TOK_EQUAL
cmp_edi_imm8 3d
jcc_nq_imm8 0b          # >next_token_check_TOK_COMMA
mov_u32_imm32 $ax 00 00 00 1d
jmp_imm32 00 00 00 7e   # >next_token_advance

# TOK_COMMA  [30] ','
# .next_token_check_TOK_COMMA
cmp_edi_imm8 2c
jcc_nq_imm8 0b          # >next_token_check_TOK_SEMICOLON
mov_u32_imm32 $ax 00 00 00 1e
jmp_imm32 00 00 00 6e   # >next_token_advance

# TOK_SEMICOLON  [31] ';'
# .next_token_check_TOK_SEMICOLON
cmp_edi_imm8 3b
jcc_nq_imm8 0b          # >next_token_check_TOK_HASHTAG
mov_u32_imm32 $ax 00 00 00 1f
jmp_imm32 00 00 00 5e   # >next_token_advance

# TOK_HASHTAG  [32] '#'
# .next_token_check_TOK_HASHTAG
cmp_edi_imm8 23
jcc_nq_imm8 0b          # >next_token_check_TOK_PLUS
mov_u32_imm32 $ax 00 00 00 20
jmp_imm32 00 00 00 4e   # >next_token_advance

# TOK_PLUS  [33] '+'
# .next_token_check_TOK_PLUS
cmp_edi_imm8 2b
jcc_nq_imm8 0b          # >next_token_check_TOK_MINUS
mov_u32_imm32 $ax 00 00 00 21
jmp_imm32 00 00 00 3e   # >next_token_advance

# TOK_MINUS  [34] '-'
# .next_token_check_TOK_MINUS
cmp_edi_imm8 2d
jcc_nq_imm8 0b          # >next_token_check_TOK_SLASH
mov_u32_imm32 $ax 00 00 00 22
jmp_imm32 00 00 00 2e   # >next_token_advance

# TOK_SLASH  [35] '/'
# .next_token_check_TOK_SLASH
cmp_edi_imm8 2f
jcc_nq_imm8 0b          # >next_token_check_TOK_DOT
mov_u32_imm32 $ax 00 00 00 23
jmp_imm32 00 00 00 1e   # >next_token_advance

# TOK_DOT  [36] '.'
# .next_token_check_TOK_DOT
cmp_edi_imm8 2e
jcc_nq_imm8 0b          # >next_token_invalid_token
mov_u32_imm32 $ax 00 00 00 24
jmp_imm32 00 00 00 0e   # >next_token_advance

# .next_token_invalid_token
mov_u32_imm32 $di 00 00 00 03
mov_u32_imm32 $ax 00 00 00 3c
syscall

# .next_token_advance
inc_r14

# .next_token_return
ret

# ======= MAIN ================================

# .entry
# args:
#   rsp | holds argc, argv and environ probably

mov_rdi_ea_rsp_disp8 00
cmp_rdi_imm8 02
jcc_q_imm8 0c
# TODO: error no file provided
mov_u32_imm32 $di 00 00 00 01
mov_u32_imm32 $ax 00 00 00 3c
syscall

# get file descriptor
mov_u32_imm32 $ax 00 00 00 02
mov_rdi_ea_rsp_disp8 10 # argv[1]
mov_rsi_imm64 00 00 00 00 00 00 00 02
mov_rdx_imm64 00 00 00 00 00 00 01 a4
syscall

cmp_rax_imm8 00
jcc_ns_imm8 0c
# TODO: error unable to read file
mov_u32_imm32 $di 00 00 00 02
mov_u32_imm32 $ax 00 00 00 3c
syscall

mov_u64_u64 $r14 $ax 1  # fd

# get file size
mov_u64_u64 $di $ax
xor_self_u32 $si
mov_u32_imm32 $dx 00 00 00 02
mov_u32_imm32 $ax 00 00 00 08
syscall

mov_u64_u64 $r13 $ax 1  # file_size

mov_u64_u64 $di $r14 0
xor_self_u32 $si
xor_self_u32 $dx
mov_u32_imm32 $ax 00 00 00 08
syscall

# allocate file size aligned to page size
mov_u32_u32 $si $r13 0
call_imm32 ff ff fd 6e  # >allocate
mov_u64_u64 $r12 $ax 1  # r12 file_ptr

# read file
mov_u64_u64 $di $r14 0
mov_u64_u64 $si $ax
mov_u64_u64 $dx $r13 0
xor_self_u32 $ax
syscall

# close file
mov_u64_u64 $di $r14 0
mov_u32_imm32 $ax 00 00 00 03
syscall

# enum TokenKind [u32] {
#   ident       = 0         '__hellow_16'
#   number      = 1         '112233'
#
#   TOK_L_PAREN     = 21    '('
#   TOK_R_PAREN     = 22    ')'
#   TOK_L_BRACE     = 23    '{'
#   TOK_R_BRACE     = 24    '}'
#   TOK_L_BRACKET   = 25    '['
#   TOK_R_BRACKET   = 26    ']'
#   TOK_STAR        = 27    '*'
#   TOK_ROOF        = 28    '^'
#   TOK_EQUAL       = 29    '='
#   TOK_COMMA       = 30    ','
#   TOK_SEMICOLON   = 31    ';'
#   TOK_HASHTAG     = 32    '#'
#   TOK_PLUS        = 33    '+'
#   TOK_MINUS       = 34    '-'
#   TOK_SLASH       = 35    '/'
#   TOK_DOT         = 36    '.'
#   
#   TODO: thinking about adding token types for //
#
#   KW_if       = 40        'if'
#   KW_while    = 41        'while'
#   WK_return   = 42        'return'
#
#   Type_s8     = 60        's8'
#   Type_s16    = 61        's16'
#   Type_s32    = 62        's32'
#   Type_s64    = 63        's64'
#
#   EOF         = 80
# };
#
# struct Token [u64] {
#   TokenKind kind;     | rax
#   u32 beg;            | rsi
# };

# ============== ELF_HEADER ============================

mov_u64_u64 $si $r13 0
shl_u64_imm8 $si 04
call_imm32 ff ff fd 47 # >allocate

# xor_edi_edi
# mov_ea_rax_base_rdi_imm64

# ============== PARSING / CODE_GEN ====================

xor_self_u32 $r14 1             # current offset in the file
xor_self_u32 $r15 1             # current line   in the file

# struct Var  {
#   u64     flags;
#   // 1    = is_ptr 
#   // 2    = is_arr
#   // 4    = is_non
#   // 8    = is_prm
#   // 32.. = array_len
#   Token   type;
#   Token   ident;
# }
# struct Func {
#   Var     *args;
#   u64     len;
#   u64     cap;
#   u64     byte_offset;
#   Var     return_type;
# }
#
# do {
#   iden = next_token
#   assert iden.kind == ident
#
#   next = next_token
#   if next.kind == L_PAREN {
#       parse_arguments
#       parse_body
#   } else if next.kind == L_BRACE {
#
#   } else {
#       error : expected l_paren or l_brace but got x on line y
#   }
# } while token.kind != EOF

call_imm32 ff ff fd b0      # >next_token

mov_u64_u64 $di $ax
mov_u32_imm32 $ax 00 00 00 3c
syscall

# .shell_script_write_final_output

BUFF=$FILE
write_ph $SIZE
cat $INST >> $FILE

ndisasm -ab64 $INST
rm $INST

chmod +x $FILE
./$FILE $EXPL

