// GENERATED BY MOB
// ================

#include <stdio.h>

typedef unsigned char           u8;
typedef unsigned short          u16;
typedef unsigned int            u32;
typedef unsigned long long int  u64;
typedef char                    s8;
typedef short                   s16;
typedef int                     s32;
typedef long long int           s64;
typedef float                   f32;
typedef double                  f64;
typedef u8 StringBuilder;
typedef struct Io Io;
typedef struct Buffer Buffer;
typedef struct ArenaChunk ArenaChunk;
typedef struct Arena Arena;
typedef struct String String;
typedef struct MobArrayHeader MobArrayHeader;
typedef struct MobHmHeader MobHmHeader;
typedef struct SocketAddress SocketAddress;
typedef struct UnixSocketAddress UnixSocketAddress;
typedef struct Window Window;

#define CREATE_MEM_WRITE_FUNC(type)                         \
    static inline void mem_write_ ## type(                  \
            u8 *buf,                                        \
            u64 *size,                                      \
            u64 cap,                                        \
            type value                                      \
    ) {                                                     \
        assert(                                             \
                *size + sizeof(value) <= cap,               \
                S("buffer out of bounds in mem_write"));    \
        assert(                                             \
                ((u64)buf + *size) % sizeof(value) == 0,    \
                S("invalid buffer alignment in mem_write"));\
        *(type*)(buf + *size) = value;                      \
        *size += sizeof(value);                             \
    }                                                       \

#define bubble_sort_impl(T)                                     \
    void bubble_sort_ ## T (                                    \
            T *mob_internal_array,                              \
            bool ascending,                                     \
            s8 (*cmp)(T *a, T *b)) {                            \
        for (u64 i = 0; i  < array_len(mob_internal_array); i++) {  \
            printf("%u/%u\n", i, array_len(mob_internal_array));    \
            for (u64 j = i + 1; j < array_len(mob_internal_array); j++) {   \
                s8 result = cmp(&mob_internal_array[i], &mob_internal_array[j]);    \
                if (!ascending) {                                                   \
                    result *= -1;                                                   \
                }                                                                   \
                                                                                    \
                if (result > 0) {                                                   \
                    u8 value[sizeof(*mob_internal_array)];                          \
                    memcpy(value, (u8*)&mob_internal_array[i], sizeof(*mob_internal_array)); \
                    memcpy((u8*)&mob_internal_array[i], (u8*)&mob_internal_array[j], sizeof(*mob_internal_array));    \
                    memcpy((u8*)&mob_internal_array[j], value, sizeof(*mob_internal_array)); \
                }   \
            }   \
        }   \
    }

#define MAX(a, b)   ((a) > (b) ? (a) : (b))
#define MIN(a, b)   ((a) < (b) ? (a) : (b))
#define ABS(a)      ((a) > ((s64)0) ? (a) : ((-(a))))
#define NULL ((void*)0)

#define PAGE_SIZE 4096
#define allocx(a, b, c, d, e, ...)  e
#define alloc(...)          allocx(__VA_ARGS__, alloc4, alloc3, alloc2)(__VA_ARGS__)
#define alloc2(a, t)        arena_alloc(a, sizeof(t), alignof(t), 1, false)
#define alloc3(a, t, c)     arena_alloc(a, sizeof(t), alignof(t), c, false)
#define alloc4(a, t, c, z)  arena_alloc(a, sizeof(t), alignof(t), c, z)
#define S(value) ((String){                                     \
        .val = u8 ## value,                                     \
        .len = (sizeof(value) / sizeof(value[0]) - 1)           \
        })
#define mob_to_string_impl(type)                                \
    String to_string_ ## type(Arena *allocator, type number) {  \
        u64 rev = 0;                                            \
        u64 len = 0;                                            \
        bool sign = number < 0;                                 \
        u64 num = ABS(number);                                  \
                                                                \
        while (num > 0) {                                       \
            rev = rev * 10 + num % 10;                          \
            num /= 10;                                          \
            len += 1;                                           \
        }                                                       \
                                                                \
        if (sign) {                                             \
            len += 1;                                           \
        }                                                       \
                                                                \
        String str = {                                          \
            .val = alloc(allocator, u8, len),                   \
            .len = len,                                         \
        };                                                      \
                                                                \
        len = 0;                                                \
        if (sign) {                                             \
            str.val[len] = '-';                                 \
            len += 1;                                           \
        }                                                       \
        while (rev > 0) {                                       \
            str.val[len] = '0' + (rev % 10);                    \
            rev /= 10;                                          \
            len += 1;                                           \
        }                                                       \
        while (len < str.len) {                                 \
            str.val[len] = '0';                                 \
            len += 1;                                           \
        }                                                       \
                                                                \
        return str;                                             \
    }                                                           
#define sb_push_char(arena, sb, c)  array_push(arena, sb, (u8)c)
#define sb_push_str(arena, sb, str) (array_grow((arena), (sb), (str).len), mob_sb_push_str((sb), (str)))
#define mob_static_array_len(array) (sizeof((array)) / sizeof((array[0])))
#define array_header(array) ((MobArrayHeader *)((void*)(array) - sizeof(MobArrayHeader)))
#define array_len(array)    ((array) ? array_header(array)->len : 0)
#define array_cap(array)    ((array) ? array_header(array)->cap : 0)
#define array_clear(array)  (array_header(array)->len = 0)
#define array_grow(arena, array, n) ((array) = mob_array_grow((arena), (array), sizeof *(array), (n)))
#define array_push(arena, array, element)                   \
    (array_grow(arena, array, 1),                           \
     (array)[array_header(array)->len++] = (element))
#define hm_header(hm)   ((MobHmHeader*)((void*)(hm) - sizeof(MobHmHeader)))
#define hm_slots(hm)    ((hm) ? hm_header(hm)->slots : 0)
#define hm_taken(hm)    ((hm) ? hm_header(hm)->taken : 0)
#define hm_take_slot(hm, pos) \
                        ((hm) ? mob_hm_take_slot(hm, pos) : 0)
#define hm_is_slot_taken(hm, pos) \
                        ((hm) ? mob_hm_is_slot_taken(hm, pos) : 0)
#define hm_grow(arena, hm) \
        ((hm) = mob_hm_maybe_grow((arena), (hm), sizeof((hm)->key), sizeof(*(hm))))
#define hm_put(arena, hm, hm_key, hm_value) \
        (hm_grow((arena), (hm)),            \
        mob_hm_put((hm), &(hm_key), sizeof((hm)->key), &(hm_value), sizeof(*(hm))))
#define hm_get(hm, hm_key)      \
        (mob_hm_get((hm), sizeof(*(hm)), &(hm_key), sizeof((hm)->key)))
#define hm_rem(arena, hm, hm_key) \
        (mob_hm_rem((hm), sizeof(*(hm)), &(hm_key), sizeof((hm)->key)))
#define PROT_READ 0x1
#define PROT_WRITE 0x2
#define PROT_EXEC 0x4
#define PROT_NONE 0x0
#define MAP_SHARED 0x01
#define MAP_PRIVATE 0x02
#define MAP_SHARED_VALIDATE 0x03
#define MAP_DROPPABLE 0x08
#define MAP_TYPE 0x0f
#define MAP_FIXED 0x10
#define MAP_FILE 0
#define MAP_ANON 0x20
#define O_RDONLY 0000000
#define O_WRONLY 0000001
#define O_RDWR 0000002
#define O_CREAT 00000100
#define S_IRWXU 00700
#define S_IRUSR 00400
#define S_IWUSR 00200
#define S_IXUSR 00100
#define S_IRWXG 00070
#define S_IRGRP 00040
#define S_IWGRP 00020
#define S_IXGRP 00010
#define S_IRWXO 00007
#define S_IROTH 00004
#define S_IWOTH 00002
#define S_IXOTH 00001
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#define SYS_CALL_READ 0
#define SYS_CALL_WRITE 1
#define SYS_CALL_OPEN 2
#define SYS_CALL_CLOSE 3
#define SYS_CALL_LSEEK 8
#define SYS_CALL_MMAP 9
#define SYS_CALL_MUNMAP 11
#define SYS_CALL_SOCKET 41
#define SYS_CALL_CONNECT 42
#define SYS_CALL_SENDTO 44
#define SYS_CALL_EXIT 60
#define UNIX_PATH_MAX 108
#define AF_UNIX 1
#define SOCK_STREAM 2
#define MSG_DONTWAIT 0x40
#define MSG_EOR 0x80
#define MSG_WAITALL 0x100
#define roundup_4(n) (((n) + 3) & -4)

struct Io{
    u8 *buf;
    u64 len;
    u64 cap;
};
struct Buffer{
    u8 *mem;
    u64 len;
};
struct ArenaChunk{
    u64 len;
    u64 cap;
    u8 *mem;
    ArenaChunk *next;
};
struct Arena{
    u64 chunk_size;
    ArenaChunk *head;
    ArenaChunk *curr;
};
struct String{
    u8 *val;
    u64 len;
};
struct MobArrayHeader{
    u64 len;
    u64 cap;
};
struct MobHmHeader{
    // check if slot is available
    u64 *used;
    u64 slots;
    u64 taken;
};
struct SocketAddress{
    u16 socket_family;
    s8  socket_data[14];
};
struct UnixSocketAddress{
    u16 socket_family;
    s8  socket_path[UNIX_PATH_MAX];
};
struct Window{
    u16 width;
    u16 height;
};

u8* memcpy(u8 *dst, u8 *src, u64 len);
u8 *memset(u8 *src, u8 value, u64 len);
bool memeql(u8 *cmp, u64 cmp_len, u8 *buf, u64 buf_len);
f64 fabs(f64 a);
u64 pow(u64 base, u16 exponent);
f64 hsqrt(u64 num);
void file_read_as_string(String str, String name);
String file_read_as_string_alloc(Arena *arena, String name);
bool write_string_to_file(String buf, String name);
void arena_init(Arena *arena, u64 chunk_size);
bool is_power_of_two(u64 value);
u64 align_to_page_size(u64 bytes_to_alloc);
u64 align_forward(u64 ptr, u64 align);
void *arena_alloc(Arena *arena, u64 size, u64 align, u64 count, bool zero);
void arena_deinit(Arena *arena);
void arena_rec_deinit(ArenaChunk *chunk);
String str_copy(Arena *allocator, String str, u64 beg, u64 end);
String from_c_string(char *str);
bool c_string_begins_with_str(const char *c_s, String s);
bool str_begins_with(String a, String b);
String str_concat(Arena *arena, String *strs);
void mob_sb_push_str(StringBuilder *sb, String str);
void *mob_array_grow(Arena *arena, void *array, u64 arr_elem_size, u64 n);
bool mob_hm_take_slot(void *hm, u64 pos);
void mob_hm_free_slot(void *hm, u64 pos);
bool mob_hm_is_slot_taken(void *hm, u64 pos);
void *mob_hm_maybe_grow(Arena *arena, void *hm, u64 key_size, u64 kv_size);
void mob_hm_put(void *hm, void *key, u64 key_size, void *value, u64 kv_size);
void *mob_hm_get(void *hm, u64 kv_size, void *key, u64 key_size);
void *mob_hm_rem(void *hm, u64 kv_size, void *key, u64 key_size);
u64 mob_hm_hasher(void *key, u64 key_size, u64 key_len);
void assert(bool condition, String msg);
u8 *os_alloc(u64 bytes);
s32 os_free(u8 *mem, u64 bytes);
s64 os_read(s32 fd, u8 *mem, u64 bytes);
s64 os_write(s32 fd, u8 *mem, u64 bytes);
s32 os_open_file(String file_name, s32 flags, u32 mode);
s32 os_close_file(s32 fd);
s64 os_file_size(s32 fd);
u64 __builtin_bit_scan_forward(u64 number);
s64 sys_read(s32 fd, void *buf, u64 count);
s64 sys_write(s32 fd, void *buf, u64 count);
s32 sys_open(char *path, s32 flags, u32 mode);
s32 sys_close(s32 fd);
s64 sys_lseek(s32 fd, s64 offset, s32 whence);
void *sys_mmap(void *addr, u64 length, s32 prot, s32 flags, s32 fd, s64 offset);
s32 sys_munmap(void *addr, u64 length);
s32 sys_socket(s32 domain, s32 type, s32 protocol);
s32 sys_connect(
        s32 socket_fd, 
        const SocketAddress *socket_addr, 
        u32 socket_len
);
s64 sys_sendto(
        s32 socket_fd, 
        u8 *buf,
        u64 len,
        s32 flags,
        const SocketAddress *dest_addr,
        u32 addr_len
);
void sys_exit(u16 exit_code);
void read_wayland_env(
        String xdg_runtime_dir_name, 
        String *xdg_runtime_dir, 
        String wayland_display_name, 
        String *wayland_display
);
s32 wayland_display_connect();
u32 wayland_display_get_registry(s32 fd);
Window create_window(u16 width, u16 height);
s32 main(s32 argc, char **argv, char **environ);

typedef struct Context {
   u8 **environment_vars;
   // TODO: maybe put allocator here too 
} Context;
Context ctx = {0};

void init_ctx(u8 **environment_vars) {
   ctx.environment_vars = environment_vars;
}

#include "../../mob/std/io.c"
#include "../../mob/std/mem.c"
#include "../../mob/std/sort.c"
#include "../../mob/std/math.c"
#include "../../mob/std/file.c"
#include "../../mob/std/types.c"
#include "../../mob/std/arena.c"
#include "../../mob/std/string.c"
#include "../../mob/std/collection.c"
#include "../../mob/std/unix_os.c"
#include "../../mob/std/unix_sys.c"
#include "../../mob/std/unix_socket.c"
#include "../../mob/std/unix_window.c"
#include "../src/bed.c"
