#!/usr/bin/sh

# x86-64 instructions: https://www.felixcloutier.com/x86/
# more reading: https://wiki.osdev.org/X86-64_Instruction_Encoding
#             - https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html
#             /r                -> reg and r/m operand
#             ib, iw, id, io    -> immediate value byte size 1, 2, 4, 8
#             +rb, +rw, +rd +ro -> lower 3 opcode bits encode register

# ea -> effective memory address
set -e

FILE="byl"
EXPL="func.byl"
INST="$(date +%s)"
BUFF=$FILE
SIZE=0

if test -e "$FILE" ; then
    rm "$FILE"
fi

write_zeroes () {
    for i in $(seq 1 "$1") ; do
        SIZE=$(expr $SIZE + 1)
        printf '\x00' >> $BUFF
    done
}

write_bits_8 () {
    SIZE=$(expr $SIZE + 1)
    printf "\\$(printf '%o' "$((2#$1))")" >> $BUFF
}

write_u8  () {
    SIZE=$(expr $SIZE + 1)
    printf "\x$1" >> "$BUFF"
}

write_u16 () {
    write_u8 $2
    write_u8 $1
}

write_u32 () {
    write_u16 $3 $4
    write_u16 $1 $2
}

write_u64 () {
    write_u32 $5 $6 $7 $8
    write_u32 $1 $2 $3 $4
}

neg_rdi () {
    write_u8 48
    write_u8 f7
    write_bits_8 11011111
}

shl_rsi_once () {
    write_u8 48
    write_u8 d1
    write_bits_8 11100110
}

add_rsi_imm32 () {
    write_u8 48
    write_u8 81
    write_bits_8 11000110
    write_u32 $1 $2 $3 $4
}

add_r13d_imm32 () {
    write_u8 41
    write_u8 81
    write_bits_8 11000101
    write_u32 $1 $2 $3 $4
}

and_r13d_imm32 () {
    write_u8 41
    write_u8 81
    write_bits_8 11100101
    write_u32 $1 $2 $3 $4
}

mov_esi_r13d () {
    write_u8 41
    write_u8 8b
    write_bits_8 11110101
}

mov_rsi_imm64 () {
    write_u8 48
    write_bits_8 10111110
    write_u64 $1 $2 $3 $4 $5 $6 $7 $8
}

mov_rsi_rax () {
    write_u8 48
    write_u8 8b
    write_bits_8 11110000
}

mov_rsi_r14 () {
    write_u8 49
    write_u8 8b
    write_bits_8 11110110
}

xor_edx_edx () {
    write_u8 33
    write_bits_8 11010010
}

xor_eax_eax () {
    write_u8 33
    write_bits_8 11000000
}

xor_edi_edi () {
    write_u8 33
    write_bits_8 11111111
}

xor_esi_esi () {
    write_u8 33
    write_bits_8 11110110
}

mov_r8d_imm32 () {
    write_u8 41
    write_u8 b8
    write_u32 $1 $2 $3 $4
}

mov_r9d_imm32 () {
    write_u8 41
    write_u8 b9
    write_u32 $1 $2 $3 $4
}

mov_r10d_imm32 () {
    write_u8 41
    write_u8 ba
    write_u32 $1 $2 $3 $4
}

mov_rdx_imm64 () {
    write_u8 48
    write_bits_8 10111010
    write_u64 $1 $2 $3 $4 $5 $6 $7 $8
}

mov_rdx_r13 () {
    write_u8 49
    write_u8 8b
    write_bits_8 11010101
}

mov_edx_imm32 () {
    write_u8        ba
    write_u32       $1 $2 $3 $4
}

mov_edi_imm32 () {
    write_bits_8    10111111
    write_u32       $1 $2 $3 $4
}

mov_r12_rax () {
    write_u8 4c
    write_u8 8b
    write_bits_8 11100000
}

mov_r13_rax () {
    write_u8 4c
    write_u8 8b
    write_bits_8 11101000
}

mov_r14_rax () {
    write_u8 4c
    write_u8 8b
    write_bits_8 11110000
}

mov_rdi_r12 () {
    write_u8 49
    write_u8 8b
    write_bits_8 11111100
}

mov_rdi_r13 () {
    write_u8 49
    write_u8 8b
    write_bits_8 11111101
}

mov_rax_ea_rcx_disp32 () {
    write_u8 48
    write_u8 0f
    write_u8 b6
    write_bits_8 10000001
    write_u32 $1 $2 $3 $4
}

mov_eax_imm32 () {
    write_bits_8    10111000
    write_u32       $1 $2 $3 $4
}

mov_rdi_rax () {
    write_u8 48
    write_u8 8b
    write_bits_8 11111000
}

mov_rdi_rcx () {
    write_u8 48
    write_u8 8b
    write_bits_8 11111001
}

mov_rdi_rbx () {
    write_u8 48
    write_u8 8b
    write_bits_8 11111011
}

mov_rcx_rax () {
    write_u8 48
    write_u8 8b
    write_bits_8 11001000
}

mov_rbx_rax () {
    write_u8 48
    write_u8 8b
    write_bits_8 11011000
}

mov_rax_rsp () {
    write_u8 48
    write_u8 89
    write_bits_8 11100000
}

movzx_edi_ea_rcx_b_rax () {
    write_u8 48
    write_u8 0f
    write_u8 b6
    write_bits_8 00111100
    write_bits_8 00000001
}

mov_rdi_ea_rcx () {
    write_u8 48
    write_u8 8b
    write_bits_8 00111001
}

mov_rdi_ea_rsp_disp8 () {
    write_u8 48
    write_u8 8b
    write_bits_8 01111100
    write_bits_8 01100100
    write_u8 $1
}

mov_rax_ea_rsp_disp8 () {
    write_u8 48
    write_u8 8b
    write_bits_8 01000100
    write_bits_8 01100100
    write_u8 $1
}

mov_rcx_ea_rsp_disp8 () {
    write_u8 48
    write_u8 8b
    write_bits_8 01001100
    write_bits_8 01100100
    write_u8 $1
}

cmp_rdi_imm8 () {
    write_u8 48
    write_u8 83
    write_bits_8 11111111
    write_u8 $1
}

cmp_rdi_rsi () {
    write_u8 48
    write_u8 39
    write_bits_8 11110111
}

cmp_rax_imm8 () {
    write_u8 48
    write_u8 83
    write_bits_8 11111000
    write_u8 $1
}

lea_rax_rcx () {
    write_u8 48
    write_u8 8d
    write_bits_8 00000001
}

jcc_s_imm8 () {
    write_u8 78
    write_u8 $1
}

jcc_ns_imm8 () {
    write_u8 79
    write_u8 $1
}

jcc_g_imm8 () {
    write_u8 77
    write_u8 $1
}

jcc_gq_imm8 () {
    write_u8 73
    write_u8 $1
}

jcc_q_imm8 () {
    write_u8 74
    write_u8 $1
}

jcc_nq_imm8 () {
    write_u8 75
    write_u8 $1
}

jcc_l_imm8 () {
    write_u8 72
    write_u8 $1
}

jcc_lq_imm8 () {
    write_u8 76
    write_u8 $1
}

inc_rax () {
    write_u8 48
    write_u8 ff
    write_bits_8 11000000
}

inc_rcx () {
    write_u8 48
    write_u8 ff
    write_bits_8 11000001
}

inc_rdx () {
    write_u8 48
    write_u8 ff
    write_bits_8 11000010
}

ret () {
    write_u8 c3
}

call_imm16 () {
    write_u8 e8
    write_u16 $1 $2
}

syscall () {
    write_u16 05 0f
}

write_ph () {
    # PROGRAM header
    ####################
    write_u32 00 00 00 01                # p_type        | program type load 
    write_u32 00 00 00 07                # p_flags       | program flags set to read, write and executable
    write_u64 00 00 00 00 00 00 00 00    # p_offset      | when does the segment start -> elf + program header
    write_u64 00 00 00 00 00 40 00 00    # p_vaddr       | virtual base address
    write_zeroes 8                       # p_paddr       | ignored on my system

    hex=$(printf '%016x' $1)
    # p_filesz      | accumulated bytes of the instructions
    write_u64 "${hex:0:2}" "${hex:2:2}" "${hex:4:2}" "${hex:6:2}" "${hex:8:2}" "${hex:10:2}" "${hex:12:2}" "${hex:14:2}"
    # p_memsz       | do not allocate more memory in the image than instructions
    write_u64 "${hex:0:2}" "${hex:2:2}" "${hex:4:2}" "${hex:6:2}" "${hex:8:2}" "${hex:10:2}" "${hex:12:2}" "${hex:14:2}"

    write_u64 00 00 00 00 00 00 00 00    # p_align       | has something to do with v_addr and p_offset 
}

# ELF header
###############
write_u32 46 4c 45 7f                # elf identifier
write_u8 02                          # class         | 64 bit
write_u8 01                          # data encoding | lsb
write_u8 01                          # file version  | 1 current
write_u8 03                          # operating system/ABI identification
write_u8 00                          # ABI version   | 0 - no features
write_zeroes 7                       # padding

write_u16 00 02                      # e_type        | exe
write_u16 00 3e                      # e_machine     | AMD
write_u32 00 00 00 01                # e_version     | current
write_u64 00 00 00 00 00 40 00 78    # e_entry       | set virtual base address
write_u64 00 00 00 00 00 00 00 40    # e_ph_off      | program header immediatle after the elf header
write_zeroes 8                       # e_shoff       | no section headers
write_zeroes 4                       # e_flags       | no flags
write_u16 00 40                      # e_h_size      | elf header size
write_u16 00 38                      # e_ph_ent_size | size of program headers
write_u16 00 01                      # e_ph_num      | number of program headers 
write_zeroes 2                       # e_shentsize   | not used.
write_zeroes 2                       # e_shnum       | not used.
write_zeroes 2                       # e_shstrndx    | not used.

SIZE=0
BUFF=$INST

# Instructions
################

# .begin
# jump to entry

# helper functions

# .allocate
# args:
#   rdi | addr -> always null ig? so gets cleared
#   rsi | len  -> expected to be set
#   rdx | protection get set by func
#   r10 | flags      get set by func
#   r8  | fd         no file mapping so -1
#   r9  | pgoff     idk 0
xor_edi_edi
mov_edx_imm32 00 00 00 03
mov_r10d_imm32 00 00 00 22
mov_r8d_imm32 ff ff ff ff
mov_r9d_imm32 00 00 00 00
mov_eax_imm32 00 00 00 09
syscall
ret

# .array_push
# args: 
#   rax | array_ptr
#   rdi | array_len
#   rsi | array_cap
#   rdx | item_ptr
#   r10 | item_len
cmp_rdi_rsi
jcc_l_imm8 00
# grow branch
# handle 0 case stupid but reduce branch 
# and should never grow too big anyway
add_rsi_imm32 00 00 10 00
shl_rsi_once


# push branch

ret


# .entry
# args:
#   rsp | holds argc, argv and environ probably
mov_rdi_ea_rsp_disp8 00
cmp_rdi_imm8 02
jcc_q_imm8 0c
# TODO: error no file provided
mov_edi_imm32 00 00 00 01
mov_eax_imm32 00 00 00 3c
syscall

# get file descriptor
mov_eax_imm32 00 00 00 02
mov_rdi_ea_rsp_disp8 10 # argv[1]
mov_rsi_imm64 00 00 00 00 00 00 00 02
mov_rdx_imm64 00 00 00 00 00 00 01 a4
syscall

cmp_rax_imm8 00
jcc_ns_imm8 0c
# TODO: error unable to read file
mov_edi_imm32 00 00 00 02
mov_eax_imm32 00 00 00 3c
syscall

mov_r12_rax # fd

# get file size
mov_rdi_rax
xor_esi_esi
mov_edx_imm32 00 00 00 02
mov_eax_imm32 00 00 00 08
syscall

mov_r13_rax # file_size

mov_rdi_r12
xor_esi_esi
xor_edx_edx
mov_eax_imm32 00 00 00 08
syscall

# .allocate
add_r13d_imm32 00 00 0f ff
and_r13d_imm32 ff ff f0 00
mov_esi_r13d
call 

mov_r14_rax  # file content memory 

# read file
mov_rdi_r12
mov_rsi_rax
mov_rdx_r13
xor_eax_eax
syscall

# close file
mov_rdi_r12
mov_eax_imm32 00 00 00 03
syscall

# tokenize 



# print file
mov_edi_imm32 00 00 00 01
mov_rsi_r14
mov_rdx_r13
mov_eax_imm32 00 00 00 01
syscall

mov_rdi_rax
mov_eax_imm32 00 00 00 3c
syscall

BUFF=$FILE
write_ph $SIZE
cat $INST >> $FILE

ndisasm -ab64 $INST
rm $INST

chmod +x $FILE
./$FILE $EXPL

